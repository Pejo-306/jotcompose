events {
    worker_connections 1024;
}

http {
    # Hide server version
    server_tokens off;

    # Logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log warn;

    # Compression
    gzip on;
    gzip_vary on;                    # Add "Vary: Accept-Encoding" header
    gzip_min_length 1000;            # Only compress responses > 1KB
    gzip_comp_level 6;               # Compression level (1-9, 6 is a good balance)
    gzip_types 
        text/plain 
        text/css 
        application/json 
        application/javascript 
        text/xml 
        application/xml 
        application/xml+rss 
        text/javascript;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=5s ipv6=off;
    resolver_timeout 2s;
    
    upstream notebooks {
        zone notebooks 64k;
        server notebooks:3000 resolve;
        keepalive 3;
    }

    upstream notes {
        zone notes 64k;
        server notes:3000 resolve;
        keepalive 3;
    }

    server {
        listen 80;

        # Fail requests fast
        proxy_connect_timeout 5s;
        proxy_send_timeout 5s;
        proxy_read_timeout 10s;

        # Retain original client information
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # Enable keepalives
        proxy_http_version 1.1;
        proxy_set_header Connection "";

        # Prevent spoofing & basic security
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-Frame-Options "DENY" always;

        # Return 503 if any service is down
        proxy_intercept_errors on;
        error_page 502 503 = @service_unavailable;
        default_type application/json;

        location = /health {
            return 200 '{"status":"up"}';
        }

        location = /health/notebooks {
            proxy_pass http://notebooks/health;
        }

        location = /health/notes {
            proxy_pass http://notes/health;
        }

        location /api/notebooks {
            proxy_pass http://notebooks;
        }

        # Block DELETE /api/notes (INTERNAL USE ONLY: see DD-3)
        location = /api/notes {
            if ($request_method = DELETE) {
                return 403 '{"error":"Forbidden"}';
            }
            proxy_pass http://notes;
        }

        location /api/notes {
            proxy_pass http://notes;
        }

        location @service_unavailable {
            return 503 '{"error":"Service temporarily unavailable"}';
        }

        location / {
            return 404 '{"error":"Not found"}';
        }
    }
}